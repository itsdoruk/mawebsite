"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ResponderSystem_exports = {};
__export(ResponderSystem_exports, {
  addNode: () => addNode,
  attachListeners: () => attachListeners,
  getResponderNode: () => getResponderNode,
  removeNode: () => removeNode,
  terminateResponder: () => terminateResponder
});
module.exports = __toCommonJS(ResponderSystem_exports);
var import_createResponderEvent = __toESM(require("./createResponderEvent")), import_ResponderTouchHistoryStore = require("./ResponderTouchHistoryStore"), import_types = require("./types"), import_utils = require("./utils"), import_utils2 = require("./utils"), emptyObject = {}, startRegistration = [
  "onStartShouldSetResponderCapture",
  "onStartShouldSetResponder",
  {
    bubbles: !0
  }
], moveRegistration = [
  "onMoveShouldSetResponderCapture",
  "onMoveShouldSetResponder",
  {
    bubbles: !0
  }
], scrollRegistration = [
  "onScrollShouldSetResponderCapture",
  "onScrollShouldSetResponder",
  {
    bubbles: !1
  }
], shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
}, emptyResponder = {
  id: null,
  idPath: null,
  node: null
}, responderListenersMap = /* @__PURE__ */ new Map(), isEmulatingMouseEvents = !1, trackedTouchCount = 0, currentResponder = {
  id: null,
  node: null,
  idPath: null
}, responderTouchHistoryStore = new import_ResponderTouchHistoryStore.ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id) {
  var config = responderListenersMap.get(id);
  return config ?? emptyObject;
}
function eventListener(domEvent) {
  var eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = !0), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = !1), // Ignore browser emulated mouse events
  !(eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1)) {
    if (isEmulatingMouseEvents && eventType === "mouseup") {
      trackedTouchCount === 0 && (isEmulatingMouseEvents = !1);
      return;
    }
    var isStartEvent = (0, import_types.isStartish)(eventType) && (0, import_utils2.isPrimaryPointerDown)(domEvent), isMoveEvent = (0, import_types.isMoveish)(eventType), isEndEvent = (0, import_types.isEndish)(eventType), isScrollEvent = (0, import_types.isScroll)(eventType), isSelectionChangeEvent = (0, import_types.isSelectionChange)(eventType), responderEvent = (0, import_createResponderEvent.default)(domEvent, responderTouchHistoryStore);
    (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
    var eventPaths = (0, import_utils2.getResponderPaths)(domEvent), wasNegotiated = !1, wantsResponder;
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      var currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = (0, import_utils2.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor), index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index),
            nodePath: eventPaths.nodePath.slice(index)
          };
        } else
          eventPaths = null;
      }
      eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = !0));
    }
    if (currentResponder.id != null && currentResponder.node != null) {
      var id = currentResponder.id, node = currentResponder.node, _getResponderConfig = getResponderConfig(id), onResponderStart = _getResponderConfig.onResponderStart, onResponderMove = _getResponderConfig.onResponderMove, onResponderEnd = _getResponderConfig.onResponderEnd, onResponderRelease = _getResponderConfig.onResponderRelease, onResponderTerminate = _getResponderConfig.onResponderTerminate, onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;
      if (responderEvent.bubbles = !1, responderEvent.cancelable = !1, responderEvent.currentTarget = node, isStartEvent)
        onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
      else if (isMoveEvent)
        onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
      else {
        var isTerminateEvent = (0, import_types.isCancelish)(eventType) || // native context menu
        eventType === "contextmenu" || // window blur
        eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
        eventType === "blur" && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
        isSelectionChangeEvent && (0, import_utils2.hasValidSelection)(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, import_utils2.hasTargetTouches)(node, domEvent.touches);
        if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
          var shouldTerminate = !0;
          (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = !1 : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === !1 && (shouldTerminate = !1))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = !1, trackedTouchCount = 0);
        }
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    for (var idPath = eventPaths.idPath, nodePath = eventPaths.nodePath, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], bubbles = shouldSetCallbacks[2].bubbles, check = function(id3, node3, callbackName) {
      var config = getResponderConfig(id3), shouldSetCallback = config[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node3, shouldSetCallback(responderEvent) === !0)) {
        var prunedIdPath = idPath.slice(idPath.indexOf(id3));
        return {
          id: id3,
          node: node3,
          idPath: prunedIdPath
        };
      }
    }, i = idPath.length - 1; i >= 0; i--) {
      var id = idPath[i], node = nodePath[i], result = check(id, node, shouldSetCallbackCaptureName);
      if (result != null)
        return result;
      if (responderEvent.isPropagationStopped() === !0)
        return;
    }
    if (bubbles)
      for (var i1 = 0; i1 < idPath.length; i1++) {
        var id1 = idPath[i1], node1 = nodePath[i1], result1 = check(id1, node1, shouldSetCallbackBubbleName);
        if (result1 != null)
          return result1;
        if (responderEvent.isPropagationStopped() === !0)
          return;
      }
    else {
      var id2 = idPath[0], node2 = nodePath[0], target = domEvent.target;
      if (target === node2)
        return check(id2, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  var currentId = currentResponder.id, currentNode = currentResponder.node, id = wantsResponder.id, node = wantsResponder.node, _getResponderConfig = getResponderConfig(id), onResponderGrant = _getResponderConfig.onResponderGrant, onResponderReject = _getResponderConfig.onResponderReject;
  if (responderEvent.bubbles = !1, responderEvent.cancelable = !1, responderEvent.currentTarget = node, currentId == null)
    onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    var _getResponderConfig1 = getResponderConfig(currentId), onResponderTerminate = _getResponderConfig1.onResponderTerminate, onResponderTerminationRequest = _getResponderConfig1.onResponderTerminationRequest, allowTransfer = !0;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === !1 && (allowTransfer = !1)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = [
  "blur",
  "scroll"
], documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
], isTamaguiResponderActive = Symbol();
function attachListeners() {
  import_utils.canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener, !0);
  }), window[isTamaguiResponderActive] = !0);
}
function addNode(id, node, config) {
  (0, import_utils2.setResponderId)(node, id), responderListenersMap.set(id, config);
}
function removeNode(id) {
  currentResponder.id === id && terminateResponder(), responderListenersMap.has(id) && responderListenersMap.delete(id);
}
function terminateResponder() {
  var id = currentResponder.id, node = currentResponder.node;
  if (id != null && node != null) {
    var onResponderTerminate = getResponderConfig(id).onResponderTerminate;
    if (onResponderTerminate != null) {
      var event = (0, import_createResponderEvent.default)({}, responderTouchHistoryStore);
      event.currentTarget = node, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = !1, trackedTouchCount = 0;
}
function getResponderNode() {
  return currentResponder.node;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addNode,
  attachListeners,
  getResponderNode,
  removeNode,
  terminateResponder
});
//# sourceMappingURL=ResponderSystem.js.map
