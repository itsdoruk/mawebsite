import { isClient, isWeb } from "@tamagui/constants";
import { getThemes } from "../config";
import { THEME_CLASSNAME_PREFIX, THEME_NAME_SEPARATOR } from "../constants/constants";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_array(arr) {
  return _array_with_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
var emptyState = {
  name: ""
};
function getHasThemeUpdatingProps(props) {
  return !!(props.name || props.componentName || props.inverse || props.reset);
}
var uid = 0, ThemeManager = /* @__PURE__ */ function() {
  "use strict";
  function ThemeManager2() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, parentManager = arguments.length > 1 ? arguments[1] : void 0;
    if (_class_call_check(this, ThemeManager2), _define_property(this, "props", void 0), _define_property(this, "id", void 0), _define_property(this, "themeListeners", void 0), _define_property(this, "parentManager", void 0), _define_property(this, "state", void 0), _define_property(this, "_allKeys", void 0), this.props = props, this.id = 0, this.themeListeners = /* @__PURE__ */ new Set(), this.parentManager = null, this.state = emptyState, this._allKeys = null, uid = (uid + 1) % Number.MAX_VALUE, this.id = uid, parentManager === "root") {
      this.updateStateFromProps(props, !1);
      return;
    }
    if (!parentManager)
      throw process.env.NODE_ENV !== "production" ? new Error("No parent manager given, this is likely due to duplicated Tamagui dependencies. Check your lockfile for mis-matched versions. It could also be from an error somewhere else in your stack causing Tamagui to recieve undefined context, you can try putting some ErrorBoundary components around other areas of your app, or a Suspense boundary.") : "\u274C 000";
    if (this.parentManager = parentManager, !this.updateStateFromProps(props, !1))
      return parentManager;
  }
  return _create_class(ThemeManager2, [
    {
      key: "updateStateFromProps",
      value: function() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props || {}, shouldNotify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        if (this.props = props, props.forceTheme)
          return this.state.theme = props.forceTheme, this.state.name = props.name || "", this.updateState(this.state, !0), this.state;
        var nextState = this.getStateIfChanged(props);
        if (nextState)
          return this.updateState(nextState, shouldNotify), nextState;
      }
    },
    {
      key: "updateState",
      value: function(nextState) {
        var _this = this, shouldNotify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        this.state = nextState, this._allKeys = null, shouldNotify && this.notify();
      }
    },
    {
      key: "getStateIfChanged",
      value: function() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props, state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state, parentManager = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.parentManager, _ = this.getState(props, parentManager);
        if (state && state !== emptyState && !_)
          return parentManager == null ? void 0 : parentManager.state;
        if (this.getStateShouldChange(_, state))
          return _;
      }
    },
    {
      key: "getStateShouldChange",
      value: function(nextState) {
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        return !(!(nextState != null && nextState.theme) || nextState.theme === (state == null ? void 0 : state.theme));
      }
    },
    {
      key: "getState",
      value: function() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props, parentManager = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.parentManager, next = getState(props, parentManager) || (parentManager == null ? void 0 : parentManager.state) || null;
        return next;
      }
    },
    {
      key: "allKeys",
      get: function() {
        var _this_parentManager;
        return this._allKeys || (this._allKeys = new Set(_to_consumable_array(((_this_parentManager = this.parentManager) === null || _this_parentManager === void 0 ? void 0 : _this_parentManager.allKeys) || []).concat(_to_consumable_array(Object.keys(this.state.theme || {}))))), this._allKeys;
      }
    },
    {
      key: "notify",
      value: function() {
        var _this = this, forced = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        if (this.themeListeners.forEach(function(cb) {
          return cb(_this.state.name, _this, forced);
        }), process.env.NODE_ENV !== "production") {
          var _numChangeEventsSent, _this_;
          (_this_ = this[_numChangeEventsSent = "_numChangeEventsSent"]) !== null && _this_ !== void 0 || (this[_numChangeEventsSent] = 0), this._numChangeEventsSent++;
        }
      }
    },
    {
      key: "onChangeTheme",
      value: function(cb, debugId) {
        var _this = this;
        if (process.env.NODE_ENV !== "production" && debugId) {
          var _this__listeningIds;
          (_this__listeningIds = this._listeningIds) !== null && _this__listeningIds !== void 0 || (this._listeningIds = /* @__PURE__ */ new Set()), this._listeningIds.add(debugId);
        }
        return this.themeListeners.add(cb), function() {
          _this.themeListeners.delete(cb);
        };
      }
    }
  ]), ThemeManager2;
}();
function getState(props, manager) {
  if (props.name && props.reset)
    throw new Error(process.env.NODE_ENV === "production" ? "\u274C004" : "Cannot reset and set a new name at the same time.");
  if (!getHasThemeUpdatingProps(props))
    return null;
  var themes = getThemes(), _getManagers = _sliced_to_array(getManagers(manager), 2), allManagers = _getManagers[0], componentManagers = _getManagers[1], isDirectParentAComponentTheme = !!(manager != null && manager.state.isComponent), startIndex = props.reset && !isDirectParentAComponentTheme ? 1 : 0, baseManager = allManagers[startIndex], parentManager = allManagers[startIndex + 1];
  if (!baseManager && props.reset)
    return process.env.NODE_ENV !== "production" && console.warn("Cannot reset, no parent theme exists"), null;
  var componentName = props.componentName, result = null, baseName = (baseManager == null ? void 0 : baseManager.state.name) || "";
  baseManager != null && baseManager.state.isComponent && (baseName = baseName.replace(/_[A-Z][A-Za-z]+/, ""));
  var nextName = props.reset ? baseName : props.name || "", allComponentThemes = componentManagers.map(function(x) {
    return (x == null ? void 0 : x.state.name) || "";
  });
  isDirectParentAComponentTheme && allComponentThemes.shift();
  for (var base = baseName.split(THEME_NAME_SEPARATOR), max = base.length, min = props.componentName && !nextName ? max : (
    // component name only don't search upwards
    0
  ), i = max; i >= min; i--) {
    var prefix = base.slice(0, i).join(THEME_NAME_SEPARATOR);
    props.inverse && (prefix = inverseThemeName(prefix));
    var potentials = [];
    if (prefix && prefix !== baseName && prefix.includes(nextName) && potentials.push(prefix), nextName && potentials.unshift(prefix ? "".concat(prefix, "_").concat(nextName) : nextName), i === 1) {
      var lastSegment = potentials.findIndex(function(x) {
        return !x.includes("_");
      });
      lastSegment > 0 && potentials.splice(lastSegment, 0, nextName);
    }
    if (componentName && !props.reset) {
      var baseLen = base.length, componentPotentials = [];
      if (nextName && baseLen > 1) {
        var beforeSeparator = base[0];
        componentPotentials.push("".concat(beforeSeparator, "_").concat(nextName, "_").concat(componentName));
      }
      if (componentPotentials.push("".concat(prefix, "_").concat(componentName)), nextName) {
        if (i > baseLen) {
          var prefixLessOne = base.slice(0, i - 1).join(THEME_NAME_SEPARATOR);
          if (prefixLessOne) {
            var lessSpecific = "".concat(prefixLessOne, "_").concat(nextName, "_").concat(componentName);
            componentPotentials.unshift(lessSpecific);
          }
        }
        var moreSpecific = "".concat(prefix, "_").concat(nextName, "_").concat(componentName);
        componentPotentials.unshift(moreSpecific);
      }
      potentials = _to_consumable_array(componentPotentials).concat(_to_consumable_array(potentials), _to_consumable_array(allComponentThemes));
    }
    var found = potentials.find(function(t) {
      return t in themes;
    });
    if (process.env.NODE_ENV !== "production" && typeof props.debug == "string" && isClient && console.info(" \u{1F537} [".concat(manager == null ? void 0 : manager.id, "] getState"), {
      props,
      found,
      potentials,
      baseManager,
      nextName,
      baseName,
      prefix
    }), found) {
      var _this, names = found.split("_"), _names = _to_array(names), firstName = _names[0], restNames = _names.slice(1), lastName = names[names.length - 1], isComponent = lastName[0] === lastName[0].toUpperCase(), scheme = firstName === "light" ? "light" : firstName === "dark" ? "dark" : void 0, pre = THEME_CLASSNAME_PREFIX, className = isWeb ? "".concat(pre, "sub_theme ").concat(pre).concat(!scheme || !restNames.length ? firstName : restNames.join("_")) : "", parentState = (_this = baseManager || parentManager) === null || _this === void 0 ? void 0 : _this.state, parentName = parentState == null ? void 0 : parentState.name;
      result = {
        name: found,
        parentName,
        theme: themes[found],
        className,
        isComponent,
        scheme
      };
      break;
    }
  }
  return process.env.NODE_ENV !== "production" && props.debug === "verbose" && isClient && (console.groupCollapsed("ThemeManager.getState()"), console.info({
    props,
    baseName,
    base,
    min,
    max
  }), console.warn("result", {
    result
  }), console.trace(), console.groupEnd()), result;
}
var inverseThemeName = function(themeName) {
  return themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
};
function getManagers(themeManager) {
  for (var comp = [], all = [], cur = themeManager; cur; )
    all.push(cur), cur.state.isComponent && comp.push(cur), cur = cur.parentManager;
  return [
    all,
    comp
  ];
}
export {
  ThemeManager,
  getHasThemeUpdatingProps,
  getManagers
};
//# sourceMappingURL=ThemeManager.js.map
