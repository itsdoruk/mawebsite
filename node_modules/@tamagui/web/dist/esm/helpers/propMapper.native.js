import { isAndroid } from "@tamagui/constants";
import { tokenCategories } from "@tamagui/helpers";
import { getConfig } from "../config";
import { getVariableValue, isVariable } from "../createVariable";
import { expandStyle } from "./expandStyle";
import { normalizeStyle } from "./normalizeStyle";
import { getFontsForLanguage, getVariantExtras } from "./getVariantExtras";
import { isObj } from "./isObj";
import { pseudoDescriptors } from "./pseudoDescriptors";
import { skipProps } from "./skipProps";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
var propMapper = function(key, value, styleStateIn, subPropsIn) {
  if (lastFontFamilyToken = null, !(!isAndroid && key === "elevationAndroid")) {
    if (value === "unset") {
      var _styleStateIn_conf_unset, unsetVal = (_styleStateIn_conf_unset = styleStateIn.conf.unset) === null || _styleStateIn_conf_unset === void 0 ? void 0 : _styleStateIn_conf_unset[key];
      if (unsetVal != null)
        value = unsetVal;
      else
        return;
    }
    var subProps = styleStateIn.styleProps.fallbackProps || subPropsIn, styleState = subProps ? new Proxy(styleStateIn, {
      get: function(_, k) {
        return k === "curProps" ? subProps : Reflect.get(_, k);
      }
    }) : styleStateIn, conf = styleState.conf, styleProps = styleState.styleProps, fontFamily = styleState.fontFamily, staticConfig = styleState.staticConfig, variants = staticConfig.variants;
    if (process.env.NODE_ENV === "development" && fontFamily && fontFamily[0] === "$" && !(fontFamily in conf.fontsParsed) && console.warn('Warning: no fontFamily "'.concat(fontFamily, '" found in config: ').concat(Object.keys(conf.fontsParsed).join(", "))), !styleProps.noExpand && variants && key in variants) {
      styleState.curProps[key] = value;
      var variantValue = resolveVariants(key, value, styleProps, styleState, "");
      if (variantValue)
        return variantValue;
    }
    if (styleProps.disableExpandShorthands || key in conf.shorthands && (key = conf.shorthands[key]), value && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps.resolveValues, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps.resolveValues))), value != null) {
      var result = (styleProps.noExpand ? null : expandStyle(key, value)) || [
        [
          key,
          value
        ]
      ];
      return key === "fontFamily" && lastFontFamilyToken && fontFamilyCache.set(result, lastFontFamilyToken), result;
    }
  }
}, resolveVariants = function(key, value, styleProps, styleState, parentVariantKey) {
  var staticConfig = styleState.staticConfig, conf = styleState.conf, debug = styleState.debug, variants = staticConfig.variants;
  if (variants) {
    var variantValue = getVariantDefinition(variants[key], value, conf);
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("\u2666\uFE0F\u2666\uFE0F\u2666\uFE0F resolve variant ".concat(key)), console.info({
      key,
      value,
      variantValue,
      variants,
      curProps: _object_spread({}, styleState.curProps)
    }), console.groupEnd()), !variantValue) {
      if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
        var name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn("No variant found: ".concat(name, ' has variant "').concat(key, '", but no matching value "').concat(value, '"'));
      }
      return;
    }
    if (typeof variantValue == "function") {
      var fn = variantValue, extras = getVariantExtras(styleState);
      variantValue = fn(value, extras), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("   expanded functional variant", key), console.info({
        fn,
        variantValue,
        extras
      }), console.groupEnd());
    }
    var fontFamilyResult;
    if (isObj(variantValue)) {
      var fontFamilyUpdate = variantValue.fontFamily || variantValue[conf.inverseShorthands.fontFamily];
      fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf), styleState.fontFamily = fontFamilyResult, process.env.NODE_ENV === "development" && debug === "verbose" && console.info("   updating font family", fontFamilyResult)), variantValue = resolveTokensAndVariants(key, variantValue, styleProps, styleState, parentVariantKey);
    }
    if (variantValue) {
      var expanded = normalizeStyle(variantValue, !!styleProps.noNormalize);
      process.env.NODE_ENV === "development" && debug === "verbose" && console.info("   expanding styles from ", variantValue, "to", expanded);
      var next = Object.entries(expanded);
      return fontFamilyResult && fontFamilyResult[0] === "$" && fontFamilyCache.set(next, getVariableValue(fontFamilyResult)), next;
    }
  }
};
function getFontFamilyFromNameOrVariable(input, conf) {
  if (isVariable(input)) {
    var val = variableToFontNameCache.get(input);
    if (val)
      return val;
    for (var key in conf.fontsParsed) {
      var familyVariable = conf.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input))
        return key;
    }
  } else if (typeof input == "string" && input[0] === "$")
    return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap(), fontFamilyCache = /* @__PURE__ */ new WeakMap(), getPropMappedFontFamily = function(expanded) {
  return expanded && fontFamilyCache.get(expanded);
}, resolveTokensAndVariants = function(key, value, styleProps, styleState, parentVariantKey) {
  var conf = styleState.conf, staticConfig = styleState.staticConfig, debug = styleState.debug, theme = styleState.theme, variants = staticConfig.variants, res = {};
  process.env.NODE_ENV === "development" && debug === "verbose" && console.info("   - resolveTokensAndVariants", key, value);
  for (var _key in value) {
    var subKey = conf.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps.noSkip && subKey in skipProps)) {
      if (styleProps.noExpand)
        res[subKey] = val;
      else if (variants && subKey in variants) {
        if (styleState.curProps[subKey] = val, parentVariantKey && parentVariantKey === key)
          res[subKey] = // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps.resolveValues, styleState) : val;
        else {
          var variantOut = resolveVariants(subKey, val, styleProps, styleState, key);
          if (variantOut) {
            var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
            try {
              for (var _iterator = variantOut[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                var _step_value = _sliced_to_array(_step.value, 2), _$key = _step_value[0], val1 = _step_value[1];
                if (val1 != null)
                  if (_$key in pseudoDescriptors) {
                    var _res, _key1, _;
                    (_ = (_res = res)[_key1 = _$key]) !== null && _ !== void 0 || (_res[_key1] = {}), Object.assign(res[_$key], val1);
                  } else
                    res[_$key] = val1;
              }
            } catch (err) {
              _didIteratorError = !0, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError)
                  throw _iteratorError;
              }
            }
          }
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps.resolveValues), process.env.NODE_ENV === "development" && debug === "verbose" && console.info("variable", subKey, res[subKey]);
        continue;
      }
      if (typeof val == "string") {
        var fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps.resolveValues, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        var _res1, _subKey, subObject = resolveTokensAndVariants(subKey, val, styleProps, styleState, key);
        process.env.NODE_ENV === "development" && debug === "verbose" && console.info("object", subKey, subObject);
        var _1;
        (_1 = (_res1 = res)[_subKey = subKey]) !== null && _1 !== void 0 || (_res1[_subKey] = {}), Object.assign(res[subKey], subObject);
      } else
        res[subKey] = val;
      if (process.env.NODE_ENV === "development" && debug) {
        var _res_subKey;
        ((_res_subKey = res[subKey]) === null || _res_subKey === void 0 ? void 0 : _res_subKey[0]) === "$" && console.warn("\u26A0\uFE0F Missing token in theme ".concat(theme.name, ":"), subKey, res[subKey], theme);
      }
    }
  }
  return res;
}, tokenCats = [
  "size",
  "color",
  "radius",
  "space",
  "zIndex"
].map(function(name) {
  return {
    name,
    spreadName: "...".concat(name)
  };
});
function getVariantDefinition(variant, value, conf) {
  if (typeof variant == "function")
    return variant;
  var exact = variant[value];
  if (exact)
    return exact;
  if (value != null) {
    var tokensParsed = conf.tokensParsed, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = tokenCats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var _step_value = _step.value, name = _step_value.name, spreadName = _step_value.spreadName;
        if (spreadName in variant && value in tokensParsed[name])
          return variant[spreadName];
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    var fontSizeVariant = variant["...fontSize"];
    if (fontSizeVariant && conf.fontSizeTokens.has(value))
      return fontSizeVariant;
  }
  return variant[":".concat(typeof value > "u" ? "undefined" : _type_of(value))] || variant["..."];
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
}, lastFontFamilyToken = null, getTokenForKey = function(key, value) {
  var resolveAs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "none", styleState = arguments.length > 3 ? arguments[3] : void 0, _staticConfig_acceptTokens;
  if (resolveAs === "none")
    return value;
  var theme = styleState.theme, _styleState_conf = styleState.conf, conf = _styleState_conf === void 0 ? getConfig() : _styleState_conf, context = styleState.context, fontFamily = styleState.fontFamily, staticConfig = styleState.staticConfig, tokensParsed = conf.tokensParsed, valOrVar, hasSet = !1, customTokenAccept = staticConfig == null || (_staticConfig_acceptTokens = staticConfig.acceptTokens) === null || _staticConfig_acceptTokens === void 0 ? void 0 : _staticConfig_acceptTokens[key];
  if (customTokenAccept) {
    var _theme_value, val = (_theme_value = theme == null ? void 0 : theme[value]) !== null && _theme_value !== void 0 ? _theme_value : tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = !0);
  }
  if (theme && value in theme)
    valOrVar = theme[value], process.env.NODE_ENV === "development" && styleState.debug === "verbose" && console.info(" - resolving ".concat(key, " to theme value ").concat(value, ": ").concat(valOrVar == null ? void 0 : valOrVar.val)), hasSet = !0;
  else {
    if (value in conf.specificTokens)
      hasSet = !0, valOrVar = conf.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          var _fontsParsed_value, fontsParsed = context != null && context.language ? getFontsForLanguage(conf.fontsParsed, context.language) : conf.fontsParsed;
          valOrVar = ((_fontsParsed_value = fontsParsed[value]) === null || _fontsParsed_value === void 0 ? void 0 : _fontsParsed_value.family) || value, lastFontFamilyToken = value, hasSet = !0;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          var defaultFont = conf.defaultFont || "$body", fam = fontFamily || defaultFont;
          if (fam) {
            var _font_, fontsParsed1 = context != null && context.language ? getFontsForLanguage(conf.fontsParsed, context.language) : conf.fontsParsed, font = fontsParsed1[fam] || fontsParsed1[defaultFont];
            valOrVar = (font == null || (_font_ = font[fontShorthand[key] || key]) === null || _font_ === void 0 ? void 0 : _font_[value]) || value, hasSet = !0;
          }
          break;
        }
      }
      for (var cat in tokenCategories)
        if (key in tokenCategories[cat]) {
          var res = tokensParsed[cat][value];
          res != null && (valOrVar = res, hasSet = !0);
        }
    }
    if (!hasSet) {
      var spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = !0);
    }
  }
  if (hasSet) {
    var out = resolveVariableValue(key, valOrVar, resolveAs);
    return process.env.NODE_ENV === "development" && styleState.debug === "verbose" && console.info("resolved", resolveAs, valOrVar, out), out;
  }
  process.env.NODE_ENV === "development" && styleState.debug === "verbose" && console.warn("Warning: no token found for ".concat(key, ", omitting"));
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none")
    return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value")
      return valOrVar.val;
    var get = valOrVar == null ? void 0 : valOrVar.get;
    return key !== "shadowColor" && typeof get == "function" ? get(resolveValues === "web" ? "web" : void 0) : valOrVar.val;
  }
  return valOrVar;
}
export {
  getFontFamilyFromNameOrVariable,
  getPropMappedFontFamily,
  getTokenForKey,
  propMapper
};
//# sourceMappingURL=propMapper.js.map
