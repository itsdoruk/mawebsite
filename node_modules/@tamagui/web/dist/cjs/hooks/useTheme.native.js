"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  activeThemeManagers: () => activeThemeManagers,
  getThemeManager: () => getThemeManager,
  getThemeProxied: () => getThemeProxied,
  useChangeThemeEffect: () => useChangeThemeEffect,
  useTheme: () => useTheme,
  useThemeWithState: () => useThemeWithState
});
module.exports = __toCommonJS(useTheme_exports);
var import_constants = require("@tamagui/constants"), import_react = require("react"), import_config = require("../config"), import_createVariable = require("../createVariable"), import_ThemeManager = require("../helpers/ThemeManager"), import_ThemeManagerContext = require("../helpers/ThemeManagerContext"), import_createShallowSetState = require("../helpers/createShallowSetState");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
var emptyProps = {
  name: null
}, cached;
function getDefaultThemeProxied() {
  if (cached)
    return cached;
  var config = (0, import_config.getConfig)(), name = config.themes.light ? "light" : Object.keys(config.themes)[0], defaultTheme = config.themes[name];
  return cached = getThemeProxied({
    theme: defaultTheme,
    name
  }), cached;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyProps, _useThemeWithState = _sliced_to_array(useThemeWithState(props), 2), _ = _useThemeWithState[0], theme = _useThemeWithState[1], res = theme || getDefaultThemeProxied();
  return res;
}, useThemeWithState = function(props) {
  var keys = (0, import_react.useRef)([]), changedThemeState = useChangeThemeEffect(props, !1, keys.current, import_constants.isServer ? void 0 : function() {
    var _props_shouldUpdate, _props_shouldUpdate1, next = (_props_shouldUpdate1 = (_props_shouldUpdate = props.shouldUpdate) === null || _props_shouldUpdate === void 0 ? void 0 : _props_shouldUpdate.call(props)) !== null && _props_shouldUpdate1 !== void 0 ? _props_shouldUpdate1 : keys.current.length > 0 ? !0 : void 0;
    if (process.env.NODE_ENV === "development" && typeof props.debug == "string" && props.debug !== "profile") {
      var _props_shouldUpdate2;
      console.info("  \u{1F3A8} useTheme() shouldUpdate?", next, import_constants.isClient ? {
        shouldUpdateProp: (_props_shouldUpdate2 = props.shouldUpdate) === null || _props_shouldUpdate2 === void 0 ? void 0 : _props_shouldUpdate2.call(props),
        keys: _to_consumable_array(keys.current)
      } : "");
    }
    return next;
  }), themeManager = changedThemeState.themeManager, state = changedThemeState.state;
  process.env.NODE_ENV === "development" && (state != null && state.theme || process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.warn("[tamagui] No theme found, this could be due to an invalid theme name (given theme props ".concat(JSON.stringify(props), `).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`)));
  var themeProxied = (0, import_react.useMemo)(function() {
    return !themeManager || !(state != null && state.theme) ? {} : getThemeProxied(state, props.deopt, themeManager, keys.current, props.debug);
  }, [
    state == null ? void 0 : state.theme,
    themeManager,
    props.deopt,
    props.debug
  ]);
  return process.env.NODE_ENV === "development" && props.debug === "verbose" && (console.groupCollapsed("  \u{1F539} [".concat(themeManager == null ? void 0 : themeManager.id, "] useTheme =>"), state == null ? void 0 : state.name), console.info("returning state", changedThemeState, "from props", props), console.groupEnd()), [
    changedThemeState,
    themeProxied
  ];
};
function getThemeProxied(param) {
  var theme = param.theme, name = param.name, scheme = param.scheme, deopt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, themeManager = arguments.length > 2 ? arguments[2] : void 0, keys = arguments.length > 3 ? arguments[3] : void 0, debug = arguments.length > 4 ? arguments[4] : void 0;
  if (!theme)
    return {};
  var config = (0, import_config.getConfig)();
  function track(key) {
    keys && !keys.includes(key) && (keys.push(key), process.env.NODE_ENV === "development" && debug && console.info(" \u{1F3A8} useTheme() tracking new key: ".concat(key)));
  }
  return new Proxy(theme, {
    has: function(_, key) {
      if (Reflect.has(theme, key))
        return !0;
      if (typeof key == "string")
        return key[0] === "$" && (key = key.slice(1)), themeManager == null ? void 0 : themeManager.allKeys.has(key);
    },
    get: function(_, key) {
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key == "string"
      ) {
        var keyString = key[0] === "$" ? key.slice(1) : key, val = theme[keyString];
        if (val && typeof val == "object")
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get: function(_2, subkey) {
              if (subkey === "val")
                track(keyString);
              else if (subkey === "get")
                return function(platform) {
                  var outVal = (0, import_createVariable.getVariable)(val);
                  if (platform !== "web" && import_constants.isIos && !deopt && config.settings.fastSchemeChange && !someParentIsInversed(themeManager) && scheme) {
                    var oppositeThemeName = name.replace(scheme === "dark" ? "dark" : "light", scheme === "dark" ? "light" : "dark"), oppositeTheme = config.themes[oppositeThemeName], oppositeVal = (0, import_createVariable.getVariable)(oppositeTheme == null ? void 0 : oppositeTheme[keyString]);
                    if (oppositeVal) {
                      var dynamicVal = {
                        dynamic: {
                          dark: scheme === "dark" ? outVal : oppositeVal,
                          light: scheme === "light" ? outVal : oppositeVal
                        }
                      };
                      return dynamicVal;
                    }
                  }
                  return track(keyString), outVal;
                };
              return Reflect.get(val, subkey);
            }
          });
        if (process.env.NODE_ENV === "development" && process.env.TAMAGUI_FEAT_THROW_ON_MISSING_THEME_VALUE === "1")
          throw new Error('[tamagui] No theme key "'.concat(key, '" found in theme ').concat(name, `. 
  Keys in theme: `).concat(Object.keys(theme).join(", ")));
      }
      return Reflect.get(_, key);
    }
  });
}
function someParentIsInversed(manager) {
  for (var cur = manager; cur; ) {
    if (!cur.parentManager)
      return !1;
    if (cur.parentManager.state.scheme !== cur.state.scheme)
      return !0;
    cur = cur.parentManager;
  }
  return !1;
}
var activeThemeManagers = /* @__PURE__ */ new Set(), _uidToManager = /* @__PURE__ */ new WeakMap(), _idToUID = {}, getId = function(id) {
  return _idToUID[id];
}, getThemeManager = function(id) {
  return _uidToManager.get(getId(id));
}, registerThemeManager = function(t) {
  if (!_idToUID[t.id]) {
    var id = _idToUID[t.id] = {};
    _uidToManager.set(id, t);
  }
}, useChangeThemeEffect = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, keys = arguments.length > 2 ? arguments[2] : void 0, shouldUpdate = arguments.length > 3 ? arguments[3] : void 0, getShouldUpdateTheme = function() {
    var manager = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : themeManager, nextState = arguments.length > 1 ? arguments[1] : void 0, prevState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : state, forceShouldChange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, forceUpdate = shouldUpdate == null ? void 0 : shouldUpdate();
    if (!(!manager || !forceShouldChange && forceUpdate === !1)) {
      var next = nextState || manager.getState(props, parentManager);
      if (forceShouldChange)
        return next;
      if (next && !(forceUpdate !== !0 && !manager.getStateShouldChange(next, prevState)))
        return next;
    }
  }, createState = function(prev) {
    var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (prev && (shouldUpdate == null ? void 0 : shouldUpdate()) === !1 && !force)
      return prev;
    var themeManager2 = parentManager, state2, hasThemeUpdatingProps = (0, import_ThemeManager.getHasThemeUpdatingProps)(props);
    if (hasThemeUpdatingProps) {
      var getNewThemeManager = function() {
        return new import_ThemeManager.ThemeManager(props, isRoot ? "root" : parentManager);
      };
      if (prev != null && prev.themeManager) {
        themeManager2 = prev.themeManager;
        var forceChange = force || !!(keys != null && keys.length), next = themeManager2.getState(props, parentManager), nextState = getShouldUpdateTheme(themeManager2, next, prev.state, forceChange);
        nextState ? (state2 = nextState, !prev.isNewTheme && !isRoot ? themeManager2 = getNewThemeManager() : themeManager2.updateState(nextState)) : prev.isNewTheme && parentManager && !next && (themeManager2 = parentManager);
      } else
        themeManager2 = getNewThemeManager(), state2 = _object_spread({}, themeManager2.state);
    }
    var isNewTheme2 = !!(themeManager2 !== parentManager || props.inverse);
    isNewTheme2 && registerThemeManager(themeManager2);
    var mounted2 = props.inverse ? isRoot || (prev == null ? void 0 : prev.mounted) : !0;
    state2 || (isNewTheme2 ? state2 = themeManager2.state : (state2 = parentManager.state, themeManager2 = parentManager));
    var wasInversed = prev == null ? void 0 : prev.inversed, nextInversed = isNewTheme2 && state2.scheme !== (parentManager == null ? void 0 : parentManager.state.scheme), inversed2 = nextInversed ? !0 : wasInversed != null ? !1 : null, response = {
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2,
      inversed: inversed2
    }, shouldReturnPrev = prev && !force && // isEqualShallow uses the second arg as the keys so this should compare without state first...
    (0, import_createShallowSetState.isEqualShallow)(prev, response) && // ... and then compare just the state, because we make a new state obj but is likely the same
    (0, import_createShallowSetState.isEqualShallow)(prev.state, state2);
    if (prev && shouldReturnPrev)
      return prev;
    if (response.state = state2, process.env.NODE_ENV === "development" && props.debug && import_constants.isClient) {
      console.groupCollapsed("\u{1F537} [".concat(themeManager2.id, "] useChangeThemeEffect createState"));
      var parentState = _object_spread({}, parentManager == null ? void 0 : parentManager.state), parentId = parentManager == null ? void 0 : parentManager.id, themeManagerState = _object_spread({}, themeManager2.state);
      console.info({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      }), console.groupEnd();
    }
    return response;
  }, disable = props.disable, parentManagerId = (0, import_react.useContext)(import_ThemeManagerContext.ThemeManagerIDContext), parentManager = getThemeManager(parentManagerId);
  if (!isRoot && !parentManager || disable)
    return {
      isNewTheme: !1,
      state: parentManager == null ? void 0 : parentManager.state,
      themeManager: parentManager
    };
  var _useState = _sliced_to_array((0, import_react.useState)(createState), 2), themeState = _useState[0], setThemeState = _useState[1], state = themeState.state, mounted = themeState.mounted, isNewTheme = themeState.isNewTheme, themeManager = themeState.themeManager, inversed = themeState.inversed, isInversingOnMount = !!(!themeState.mounted && props.inverse);
  return import_constants.isServer || ((0, import_react.useEffect)(function() {
    if (themeManager) {
      if (props.inverse && !mounted) {
        setThemeState(function(prev) {
          return createState(_object_spread_props(_object_spread({}, prev), {
            mounted: !0
          }));
        });
        return;
      }
      (isNewTheme || getShouldUpdateTheme(themeManager)) && (activeThemeManagers.add(themeManager), setThemeState(createState));
      var selfListenerDispose = themeManager.onChangeTheme(function(_a, _b, forced) {
        forced && setThemeState(function(prev) {
          return createState(prev, !0);
        });
      }), disposeChangeListener = parentManager == null ? void 0 : parentManager.onChangeTheme(function(name, manager, forced) {
        var force = forced || (shouldUpdate == null ? void 0 : shouldUpdate()) || props.deopt || props["disable-child-theme"], shouldTryUpdate = force ?? !!(keys != null && keys.length || isNewTheme);
        process.env.NODE_ENV === "development" && props.debug === "verbose" && console.info(" \u{1F538} onChange", themeManager.id, {
          force,
          shouldTryUpdate,
          props,
          name,
          manager,
          keys
        }), shouldTryUpdate && setThemeState(function(prev) {
          return createState(prev, force);
        });
      }, themeManager.id);
      return function() {
        selfListenerDispose(), disposeChangeListener == null || disposeChangeListener(), isNewTheme && activeThemeManagers.delete(themeManager);
      };
    }
  }, [
    themeManager,
    parentManager,
    isNewTheme,
    props.componentName,
    props.inverse,
    props.name,
    props.reset,
    mounted
  ]), process.env.NODE_ENV === "development" && props.debug !== "profile" && (0, import_react.useEffect)(function() {
    var _globalThis, _TamaguiThemeManagers, _;
    return (_ = (_globalThis = globalThis)[_TamaguiThemeManagers = "TamaguiThemeManagers"]) !== null && _ !== void 0 || (_globalThis[_TamaguiThemeManagers] = /* @__PURE__ */ new Set()), globalThis.TamaguiThemeManagers.add(themeManager), function() {
      globalThis.TamaguiThemeManagers.delete(themeManager);
    };
  }, [
    themeManager
  ])), isInversingOnMount ? {
    isNewTheme: !1,
    inversed: !1,
    themeManager: parentManager,
    state: _object_spread_props(_object_spread({
      name: ""
    }, parentManager == null ? void 0 : parentManager.state), {
      className: ""
    })
  } : {
    state,
    isNewTheme,
    inversed,
    themeManager
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activeThemeManagers,
  getThemeManager,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
});
//# sourceMappingURL=useTheme.js.map
