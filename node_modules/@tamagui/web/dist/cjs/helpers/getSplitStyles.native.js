"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var getSplitStyles_exports = {};
__export(getSplitStyles_exports, {
  PROP_SPLIT: () => PROP_SPLIT,
  getSplitStyles: () => getSplitStyles,
  getSubStyle: () => getSubStyle,
  useSplitStyles: () => useSplitStyles
});
module.exports = __toCommonJS(getSplitStyles_exports);
var import_constants = require("@tamagui/constants"), import_helpers = require("@tamagui/helpers"), import_react = require("react"), import_config = require("../config"), import_accessibilityDirectMap = require("../constants/accessibilityDirectMap"), import_constants2 = require("../constants/constants"), import_isDevTools = require("../constants/isDevTools"), import_useMedia = require("../hooks/useMedia"), import_createMediaStyle = require("./createMediaStyle"), import_expandStyles = require("./expandStyles"), import_getGroupPropParts = require("./getGroupPropParts"), import_getStylesAtomic = require("./getStylesAtomic"), import_insertStyleRule = require("./insertStyleRule"), import_log = require("./log"), import_normalizeValueWithProperty = require("./normalizeValueWithProperty"), import_propMapper = require("./propMapper"), import_pseudoDescriptors = require("./pseudoDescriptors"), import_skipProps = require("./skipProps"), import_transformsToString = require("./transformsToString");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
var IS_STATIC = process.env.IS_STATIC === "is_static", conf, PROP_SPLIT = "-";
function isValidStyleKey(key, staticConfig) {
  var _staticConfig_acceptTokens, validStyleProps = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? import_helpers.stylePropsText : import_helpers.validStyles);
  return validStyleProps[key] || ((_staticConfig_acceptTokens = staticConfig.acceptTokens) === null || _staticConfig_acceptTokens === void 0 ? void 0 : _staticConfig_acceptTokens[key]);
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) {
  conf = conf || (0, import_config.getConfig)(), import_constants.isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  var shorthands = conf.shorthands, isHOC = staticConfig.isHOC, isText = staticConfig.isText, isInput = staticConfig.isInput, variants = staticConfig.variants, isReactNative = staticConfig.isReactNative, inlineProps = staticConfig.inlineProps, inlineWhenUnflattened = staticConfig.inlineWhenUnflattened, parentStaticConfig = staticConfig.parentStaticConfig, acceptsClassName = staticConfig.acceptsClassName, viewProps = {}, mediaState = styleProps.mediaState || import_useMedia.mediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && import_constants.isWeb && !styleProps.noClassNames, rulesToInsert = void 0, classNames = {}, transforms = {}, pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0, styleState = {
    curProps: {},
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && import_constants.isClient && (console.groupCollapsed("getSplitStyles (collapsed)"), (0, import_log.log)({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    componentState,
    styleState,
    theme: _object_spread({}, theme)
  }), console.groupEnd());
  for (var keyOg in props) {
    var _parentStaticConfig_variants, keyInit = keyOg, valInit = props[keyOg];
    if (process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd(), styleProps.disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit !== "className" && !(keyInit in usedKeys)) {
      if (keyInit in import_skipProps.skipProps && !styleProps.noSkip && !isHOC) {
        if (keyInit === "group" && 0)
          var identifier, containerType, containerCSS;
        continue;
      }
      var valInitType = typeof valInit > "u" ? "undefined" : _type_of(valInit), isValidStyleKeyInit = isValidStyleKey(keyInit, staticConfig);
      if (0 && isValidStyleKeyInit && valInitType === "string" && valInit[0] === "_") {
        var isValidClassName, isMediaOrPseudo;
        if ((isValidClassName || isMediaOrPseudo) && !shouldDoClasses)
          var _styleState;
      }
      if (valInit !== props[keyInit] && (styleState.curProps[keyInit] = valInit), !isValidStyleKeyInit) {
        if (!import_constants.isAndroid && keyInit === "elevationAndroid")
          continue;
        if (keyInit === "userSelect")
          keyInit = "selectable", valInit = valInit !== "none";
        else if (keyInit === "role") {
          viewProps.accessibilityRole = import_accessibilityDirectMap.accessibilityWebRoleToNativeRole[valInit];
          continue;
        } else if (keyInit.startsWith("aria-")) {
          if (import_accessibilityDirectMap.webToNativeAccessibilityDirectMap[keyInit]) {
            var nativeA11yProp = import_accessibilityDirectMap.webToNativeAccessibilityDirectMap[keyInit];
            keyInit === "aria-hidden" && (viewProps["aria-hidden"] = valInit), viewProps[nativeA11yProp] = valInit;
            continue;
          }
          if (import_accessibilityDirectMap.nativeAccessibilityValue[keyInit]) {
            var field = import_accessibilityDirectMap.nativeAccessibilityValue[keyInit];
            viewProps.accessibilityValue ? viewProps.accessibilityValue[field] = valInit : viewProps.accessibilityValue = _define_property({}, field, valInit);
          } else if (import_accessibilityDirectMap.nativeAccessibilityState[keyInit]) {
            var field1 = import_accessibilityDirectMap.nativeAccessibilityState[keyInit];
            viewProps.accessibilityState ? viewProps.accessibilityState[field1] = valInit : viewProps.accessibilityState = _define_property({}, field1, valInit);
          }
          continue;
        } else if (keyInit.startsWith("data-"))
          continue;
      }
      if (keyInit === "dataSet") {
        for (var keyInit1 in valInit)
          viewProps["data-".concat(hyphenate(keyInit1))] = valInit[keyInit1];
        continue;
      }
      if (0 && !styleProps.noExpand) {
        var didUseKeyInit;
        if (!isReactNative)
          switch (keyInit) {
            case "accessibilityRole":
            case "accessibilityLabelledBy":
            case "accessibilityFlowTo":
            case "accessibilityControls":
            case "accessibilityDescribedBy":
            case "accessibilityKeyShortcuts":
            case "accessibilityLiveRegion":
            case "accessibilityReadOnly":
            case "accessibilityRequired":
            default:
          }
      }
      var isShorthand = keyInit in shorthands, isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant, isPseudo = keyInit in import_helpers.validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && (0, import_useMedia.isMediaKey)(keyInit), isMediaOrPseudo1 = !!(isMedia || isPseudo), isStyleProp = isValidStyleKeyInit || isMediaOrPseudo1 || isVariant && !styleProps.noExpand || isShorthand;
      if (!(isStyleProp && (props.asChild === "except-style" || props.asChild === "except-style-web"))) {
        var shouldPassProp = !isStyleProp || // is in parent variants
        isHOC && (parentStaticConfig == null ? void 0 : parentStaticConfig.variants) && keyInit in parentStaticConfig.variants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo1 || parentVariant || keyInit in import_skipProps.skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
        if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("  \u{1F511} ".concat(keyOg).concat(keyInit !== keyOg ? " (shorthand for ".concat(keyInit, ")") : "", " ").concat(shouldPassThrough ? "(pass)" : "")), (0, import_log.log)({
          isVariant,
          valInit,
          shouldPassProp
        }), import_constants.isClient && (0, import_log.log)({
          variants,
          variant: variants == null ? void 0 : variants[keyInit],
          isVariant,
          isHOCShouldPassThrough,
          curProps: _object_spread({}, styleState.curProps),
          parentStaticConfig
        })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo1), !isVariant)) {
          process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
          continue;
        }
        if (!styleProps.noSkip && keyInit in import_skipProps.skipProps) {
          process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
          continue;
        }
        (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
        var avoidPropMap = isMediaOrPseudo1 || !isVariant && !isValidStyleKeyInit, expanded = avoidPropMap ? null : (0, import_propMapper.propMapper)(keyInit, valInit, styleState);
        if (!avoidPropMap) {
          if (!expanded)
            continue;
          var next = (0, import_propMapper.getPropMappedFontFamily)(expanded);
          next && (styleState.fontFamily = next);
        }
        if (process.env.NODE_ENV === "development" && debug === "verbose") {
          console.groupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
          try {
            !import_constants.isServer && import_isDevTools.isDevTools && ((0, import_log.log)({
              expanded,
              styleProps,
              componentState,
              isVariant,
              variant: variants == null ? void 0 : variants[keyInit],
              shouldPassProp,
              isHOCShouldPassThrough,
              theme,
              usedKeys: _object_spread({}, usedKeys),
              curProps: _object_spread({}, styleState.curProps)
            }), (0, import_log.log)("expanded", expanded, `
usedKeys`, _object_spread({}, usedKeys), `
current`, _object_spread({}, styleState.style)));
          } catch {
          }
          console.groupEnd();
        }
        for (var key = keyInit, val = valInit, max = expanded ? expanded.length : 1, i = 0; i < max; i++) {
          var _parentStaticConfig_variants1;
          if (expanded) {
            var _expanded_i = _sliced_to_array(expanded[i], 2), k = _expanded_i[0], v = _expanded_i[1];
            key = k, val = v;
          }
          if (val != null && !(key in usedKeys)) {
            if (isPseudo = key in import_helpers.validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && (0, import_useMedia.isMediaKey)(key), isMediaOrPseudo1 = !!(isMedia || isPseudo), isVariant = variants && key in variants, inlineProps != null && inlineProps.has(key) || IS_STATIC && (inlineWhenUnflattened != null && inlineWhenUnflattened.has(key))) {
              var _props_key;
              viewProps[key] = (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : val;
            }
            var shouldPassThrough1 = styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo1 || (parentStaticConfig == null || (_parentStaticConfig_variants1 = parentStaticConfig.variants) === null || _parentStaticConfig_variants1 === void 0 ? void 0 : _parentStaticConfig_variants1[keyInit]));
            if (shouldPassThrough1) {
              passDownProp(viewProps, key, val, isMediaOrPseudo1), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed(" - passing down prop ".concat(key)), (0, import_log.log)({
                val,
                after: _object_spread({}, viewProps[key])
              }), console.groupEnd());
              continue;
            }
            if (isPseudo) {
              if (!val)
                continue;
              var pseudoStyleObject = getSubStyle(styleState, key, val, styleProps.noClassNames), descriptor = import_pseudoDescriptors.pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
              if (!descriptor)
                continue;
              if (!shouldDoClasses || IS_STATIC) {
                var _pseudos, _key;
                if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key] || (_pseudos[_key] = {}), IS_STATIC) {
                  Object.assign(pseudos[key], pseudoStyleObject);
                  continue;
                }
              }
              if (shouldDoClasses && !isExit) {
                var pseudoStyles = (0, import_getStylesAtomic.getStyleAtomic)(pseudoStyleObject, descriptor);
                process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo (classes)", key), (0, import_log.log)({
                  pseudoStyleObject,
                  pseudoStyles
                }), console.groupEnd());
                var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
                try {
                  for (var _iterator = pseudoStyles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                    var psuedoStyle = _step.value, fullKey = "".concat(psuedoStyle.property).concat(PROP_SPLIT).concat(descriptor.name);
                    fullKey in usedKeys || mergeClassName(transforms, classNames, fullKey, psuedoStyle.identifier, isMediaOrPseudo1, !0);
                  }
                } catch (err) {
                  _didIteratorError = !0, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError)
                      throw _iteratorError;
                  }
                }
              }
              if (!shouldDoClasses || isExit || isEnter) {
                var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = componentState[descriptorKey] === !1;
                isExit && (isDisabled = !styleProps.isExiting), isEnter && (isDisabled = componentState.unmounted === "should-enter" ? !0 : !componentState.unmounted), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo", key, {
                  isDisabled
                }), (0, import_log.log)({
                  pseudoStyleObject,
                  isDisabled,
                  descriptor,
                  componentState
                }), console.groupEnd());
                var importance = descriptor.priority;
                for (var pkey in pseudoStyleObject) {
                  var val1 = pseudoStyleObject[pkey];
                  if (isDisabled) {
                    var defaultValues = animatableDefaults[pkey];
                    defaultValues != null && !(pkey in usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
                  } else {
                    var curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                    if (shouldMerge) {
                      var _pseudos1, _key1;
                      pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key] || (_pseudos1[_key1] = {}), pseudos[key][pkey] = val1, mergeStyle(styleState, pkey, val1);
                    }
                    process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("    subKey", pkey, shouldMerge, {
                      importance,
                      curImportance,
                      pkey,
                      val: val1
                    });
                  }
                }
                if (!isDisabled)
                  for (var key1 in val) {
                    var k1 = shorthands[key1] || key1;
                    usedKeys[k1] = Math.max(importance, usedKeys[k1] || 0);
                  }
              }
              continue;
            }
            if (isMedia) {
              if (!val)
                continue;
              if (isMedia === "platform") {
                var platform = key.slice(10);
                if (
                  // supports web, ios, android
                  platform !== import_constants.currentPlatform && // supports web, native
                  platform !== "native"
                )
                  continue;
              }
              hasMedia || (hasMedia = !0);
              var mediaKeyShort = key.slice(1);
              process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("  \u{1F4FA} ".concat(key), {
                key,
                val,
                props,
                shouldDoClasses,
                acceptsClassName,
                componentState
              });
              var hasSpace = val.space;
              if ((hasSpace || !shouldDoClasses) && (Array.isArray(hasMedia) || (hasMedia = []), hasMedia.push(mediaKeyShort)), shouldDoClasses) {
                var mediaStyle = getSubStyle(styleState, key, val, !1);
                if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
                  var importance1 = (0, import_useMedia.getMediaImportanceIfMoreImportant)(mediaKeyShort, "space", usedKeys, !0);
                  importance1 && (space = val.space, usedKeys.space = importance1, process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("Found more important space for current media ".concat(mediaKeyShort, ": ").concat(val, " (importance: ").concat(importance1, ")")));
                }
                var mediaStyles = (0, import_getStylesAtomic.getStylesAtomic)(mediaStyle), priority = mediaStylesSeen;
                mediaStylesSeen += 1;
                var _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
                try {
                  for (var _iterator1 = mediaStyles[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
                    var style = _step1.value, out = (0, import_createMediaStyle.createMediaStyle)(style, mediaKeyShort, import_useMedia.mediaQueryConfig, isMedia, !1, priority);
                    process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("\u{1F4FA} media style:", out);
                    var fullKey1 = "".concat(style.property).concat(PROP_SPLIT).concat(mediaKeyShort).concat(style.pseudo || "");
                    fullKey1 in usedKeys || mergeClassName(transforms, classNames, fullKey1, out.identifier, !0, !0);
                  }
                } catch (err) {
                  _didIteratorError1 = !0, _iteratorError1 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
                  } finally {
                    if (_didIteratorError1)
                      throw _iteratorError1;
                  }
                }
              } else {
                var mediaStyle1 = getSubStyle(styleState, key, val, !0), isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
                if (!isThemeMedia && !isPlatformMedia && !isGroupMedia && !mediaState[mediaKeyShort])
                  continue;
                var importanceBump = 0;
                if (isThemeMedia) {
                  dynamicThemeAccess = !0;
                  var mediaThemeName = mediaKeyShort.slice(6);
                  if (!(themeName === mediaThemeName || themeName.startsWith(mediaThemeName)))
                    continue;
                } else if (isGroupMedia) {
                  var _componentState_group, groupInfo = (0, import_getGroupPropParts.getGroupPropParts)(mediaKeyShort), groupName = groupInfo.name, groupContext = context == null ? void 0 : context.groups.state[groupName];
                  if (!groupContext) {
                    process.env.NODE_ENV === "development" && debug && console.warn("No parent with group prop, skipping styles: ".concat(groupName));
                    continue;
                  }
                  var groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
                  if (groupMediaKey) {
                    mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                    var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                    if (!mediaState1 && groupContext.layout && (isActive = (0, import_useMedia.mediaKeyMatch)(groupMediaKey, groupContext.layout)), !isActive)
                      continue;
                    importanceBump = 2;
                  }
                  if (groupPseudoKey) {
                    pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                    var componentGroupPseudoState = (componentGroupState || // fallback to context initially
                    context.groups.state[groupName]).pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey];
                    if (!isActive1)
                      continue;
                    var priority1 = import_pseudoDescriptors.pseudoPriorities[groupPseudoKey];
                    importanceBump = priority1;
                  }
                }
                for (var subKey in mediaStyle1) {
                  var _styleState1;
                  if (subKey === "space") {
                    space = valInit.space;
                    continue;
                  }
                  (_styleState1 = styleState).style || (_styleState1.style = {}), mergeMediaByImportance(styleState, mediaKeyShort, subKey, mediaStyle1[subKey], usedKeys, mediaState[mediaKeyShort], importanceBump), key === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
                }
              }
              continue;
            }
            if (key === "pointerEvents") {
              viewProps[key] = val;
              continue;
            }
            if (
              // is HOC we can just pass through the styles as props
              // this fixes issues where style prop got merged with wrong priority
              !isHOC && (isValidStyleKey(key, staticConfig) || import_constants.isAndroid && key === "elevation")
            ) {
              mergeStyle(styleState, key, val);
              continue;
            }
            isVariant || (viewProps[key] = val);
          }
        }
        if (process.env.NODE_ENV === "development" && debug === "verbose") {
          try {
            (0, import_log.log)(" \u2714\uFE0F expand complete", keyInit), (0, import_log.log)("style", _object_spread({}, styleState.style)), (0, import_log.log)("transforms", _object_spread({}, transforms)), (0, import_log.log)("viewProps", _object_spread({}, viewProps));
          } catch {
          }
          console.groupEnd();
        }
      }
    }
  }
  var avoidNormalize = styleProps.noNormalize === !1;
  if (!avoidNormalize) {
    if (styleState.style && ((0, import_expandStyles.fixStyles)(styleState.style), import_constants.isWeb && !staticConfig.isReactNative && (0, import_getStylesAtomic.styleToCSS)(styleState.style)), styleState.flatTransforms) {
      var _styleState2;
      (_styleState2 = styleState).style || (_styleState2.style = {}), Object.entries(styleState.flatTransforms).sort(function(param, param1) {
        var _param = _sliced_to_array(param, 1), a = _param[0], _param1 = _sliced_to_array(param1, 1), b = _param1[0];
        return a.localeCompare(b);
      }).forEach(function(param) {
        var _param = _sliced_to_array(param, 2), key6 = _param[0], val4 = _param[1];
        mergeTransform(styleState.style, key6, val4, !0);
      });
    }
    if (parentSplitStyles) {
      if (0 && shouldDoClasses)
        for (var key2 in parentSplitStyles.classNames)
          var val2;
      if (!shouldDoClasses)
        for (var key3 in parentSplitStyles.style) {
          var _styleState3;
          key3 in classNames || styleState.style && key3 in styleState.style || ((_styleState3 = styleState).style || (_styleState3.style = {}), styleState.style[key3] = parentSplitStyles.style[key3]);
        }
    }
  }
  if (0)
    var _styleState_style, shouldStringifyTransforms;
  if (0) {
    if (styleState.style && shouldDoClasses) {
      var retainedStyles, shouldRetain;
      if (!styleState.style.$$css) {
        var atomic, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2;
        try {
          for (var _iterator2, _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0)
            var atomicStyle, _props_animateOnly, key4, isAnimatedAndAnimateOnly, nonAnimatedAnimateOnly;
        } catch (err) {
        } finally {
          try {
          } finally {
          }
        }
      }
      if (transforms)
        for (var namespace in transforms) {
          var _transforms_namespace, hash, val3, identifier1;
          if (import_constants.isClient && !insertedTransforms[identifier1])
            var rule;
        }
    }
    if (props.style && !isHOC) {
      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3;
      try {
        for (var _iterator3, _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
          var style1;
          if (style1 && !style1.$$css)
            var _styleState4;
        }
      } catch (err) {
      } finally {
        try {
        } finally {
        }
      }
    }
    if (import_constants.isWeb && !isReactNative && viewProps.tabIndex == null)
      var _viewProps_focusable, isFocusable, role;
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, style2 = styleState.style;
  if (style2 != null && style2.fontFamily) {
    var _getFont, faceInfo = (_getFont = (0, import_config.getFont)(style2.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style2.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style2.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style2.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style2.fontWeight, delete style2.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && (0, import_log.log)("Found fontFamily native: ".concat(style2.fontFamily), faceInfo);
  }
  var asChild = props.asChild, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!asChildExceptStyleLike) {
    var style3 = styleState.style;
    if (0) {
      var _staticConfig_defaultProps, fontFamily, fontFamilyClassName, groupClassName, componentNameFinal, componentClassName, classList, finalClassName;
      if (!styleProps.noMergeStyle) {
        if (!(styleProps.isAnimated && !conf.animations.supportsCSSVars && isReactNative)) {
          if (isReactNative) {
            var cnStyles, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4;
            try {
              for (var _iterator4, _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = !0)
                var name;
            } catch (err) {
            } finally {
              try {
              } finally {
              }
            }
          }
        }
      }
    } else
      style3 && !styleProps.noMergeStyle && (viewProps.style = style3);
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose" && import_isDevTools.isDevTools) {
    console.groupCollapsed("\u{1F539} getSplitStyles ===>");
    try {
      var logs = _object_spread_props(_object_spread({}, result), {
        className,
        componentState,
        transforms,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      });
      for (var key5 in logs)
        (0, import_log.log)(key5, logs[key5]);
    } catch {
    }
    console.groupEnd();
  }
  return result;
};
function mergeClassName(transforms, classNames, key, val) {
  var isMediaOrPseudo = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, isInsertingNow = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
  if (0 && !isInsertingNow && val[0] === "_" && val.startsWith("_transform-"))
    var _transforms, _ns, ns, transform;
}
function mergeStyle(styleState, key, val) {
  var disableNormalize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, classNames = styleState.classNames, viewProps = styleState.viewProps, usedKeys = styleState.usedKeys, styleProps = styleState.styleProps, staticConfig = styleState.staticConfig;
  if (import_constants.isWeb && (val == null ? void 0 : val[0]) === "_") {
    var _usedKeys, _key;
    classNames[key] = val, (_usedKeys = usedKeys)[_key = key] || (_usedKeys[_key] = 1);
  } else if (key in import_helpers.stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = import_constants.isWeb && !disableNormalize && !styleProps.noNormalize, out = shouldNormalize ? (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key) : val;
    if (
      // acceptTokens are for props not styles
      staticConfig.acceptTokens && key in staticConfig.acceptTokens
    )
      viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key] = out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var staticConfig = styleState.staticConfig, props = styleState.props, conf2 = styleState.conf, styleProps = styleState.styleProps, styleOut = {};
  for (var key in styleIn) {
    var val = styleIn[key];
    key = conf2.shorthands[key] || key;
    var expanded = (0, import_propMapper.propMapper)(key, val, styleState, _object_spread({}, props, props[subKey]));
    if (!(!expanded || !staticConfig.isHOC && key in import_skipProps.skipProps && !styleProps.noSkip)) {
      var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = expanded[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var _step_value = _sliced_to_array(_step.value, 2), skey = _step_value[0], sval = _step_value[1];
          !avoidMergeTransform && skey in import_helpers.stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(sval, key);
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
    }
  }
  return styleProps.noNormalize || (0, import_expandStyles.fixStyles)(styleOut), styleOut;
};
var useSplitStyles = function(a, b, c, d, e, f, g, h, i, j) {
  var res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return res;
};
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = _object_spread_props(_object_spread({}, Object.fromEntries(Object.entries(import_helpers.tokenCategories.color).map(function(param) {
  var _param = _sliced_to_array(param, 2), k = _param[0], v = _param[1];
  return [
    k,
    defaultColor
  ];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return "-".concat(match.toLowerCase());
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"](_define_property({}, mapTransformKeys[key] || key, val)));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (shouldMergeObject) {
    var next = _object_spread({}, viewProps[key], val);
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump) {
  var importance = (0, import_useMedia.getMediaImportanceIfMoreImportant)(mediaKey, key, importancesUsed, isSizeMedia);
  return importanceBump && (importance = (importance || 0) + importanceBump), importance === null ? !1 : (importancesUsed[key] = importance, mergeStyle(styleState, key, value), !0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
});
//# sourceMappingURL=getSplitStyles.js.map
